ngpus_per_node: 4  # 4  # number of GPUs per node; each GPU is used to run a CV iteration
rank: null
train_parallel: true  # set to true to run CV iterations in parallel (one per GPU); only useful when number of GPUs > 1
rnd_seed: 2  # random seed used to select the validation fold in each CV iteration
paths:
  # experiment directory; results are saved here
  experiment_root_dir: null
#  # TFRecord directory with the CV folds
#  tfrec_dir: /home6/msaragoc/work_dir/Kepler-TESS_exoplanet/data/tfrecords/TESS/spoc_ffi/cv_tfrecords_tess_spoc_ffi_s47-61_1-25-2024_1121
  # YAML file containing a list of CV iterations, where each CV iteration is a dictionary with the TFRecord filepaths
  # for each training, validation, and test set folds combination (i.e., {'train': ['/path/to/train_shard-xxxx', ...],
  # 'val': ['/path/to/val_shard-xxxx', ...], 'test': ['/path/to/test_shard-xxxx']}
  cv_folds: /home6/msaragoc/work_dir/Kepler-TESS_exoplanet/data/tfrecords/TESS/tfrecords_tess_tic10837041.1_s30_4-8-2024_1233_addplaceholderfeature/cv_iters_fps.yaml
  # path to root directory with ensemble models created in a CV experiment
  models_cv_root_dir: null

data_fields: # scalar data from TFRecords to add to ranking table
  uid: 'string'
  target_id: 'int_scalar'
  tce_plnt_num: 'int_scalar'
  #  'oi': 'float_scalar'
  label: 'string'
#  label_id: 'int_scalar'
#  odd_even_flag: 'string'
#  sec_flag: 'string'
#  centroid_flag: 'string'
#  not_transit_like_flag: 'string'
  #  'TESS Disposition': 'string'
  tce_period: 'float_scalar'
  tce_duration: 'float_scalar'
  tce_time0bk: 'float_scalar'
#  'transit_depth': 'float_scalar'
#  tce_depth: 'float_scalar'
  ruwe: 'float_scalar'
  tce_prad: 'float_scalar'
  tce_max_mult_ev: 'float_scalar'
#  'sigma_oot_odd': 'float_scalar'
#  'sigma_it_odd': 'float_scalar'
#  'sigma_oot_even': 'float_scalar'
#  'sigma_it_even': 'float_scalar'

config:
  # if true, will use transformer branches. Otherwise, will use convolutional branches for unfolded flux data
  use_transformer: false
  multi_class: false  # switch to multiclass classification

features_set: # each key-value pair is feature_name: {'dim': feature_dim, 'dtype': feature_dtype}

#  # unfolded flux
#  unfolded_local_flux_view_fluxnorm: { 'dim': [ 20, 31 ], 'dtype': float }
#  #  unfolded_global_flux_view_fluxnorm: { 'dim': [ 20, 301 ], 'dtype': float }
#  tce_num_transits_norm: { 'dim': [ 1, ], 'dtype': float }

  # flux
  global_flux_view_fluxnorm: { 'dim': [ 301, 1 ], 'dtype': float }
  global_flux_view_fluxnorm_var: { 'dim': [ 301, 1 ], 'dtype': float }

  local_flux_view_fluxnorm: { 'dim': [ 31, 1 ], 'dtype': float }
  local_flux_view_fluxnorm_var: { 'dim': [ 31, 1 ], 'dtype': float }
#  transit_depth_norm: { 'dim': [ 1, ], 'dtype': float }
#  tce_depth_norm: { 'dim': [ 1, ], 'dtype': float }
#  tce_max_mult_ev_norm: { 'dim': [ 1, ], 'dtype': float }
#  tce_max_sngle_ev_norm: { 'dim': [ 1, ], 'dtype': float }
#  tce_robstat_norm: { 'dim': [ 1, ], 'dtype': float }
#  tce_model_chisq_norm: { 'dim': [ 1, ], 'dtype': float }

#  # odd-even flux related features
#  local_flux_odd_view_fluxnorm: { 'dim': [ 31, 1 ], 'dtype': float }
#  local_flux_even_view_fluxnorm: { 'dim': [ 31, 1 ], 'dtype': float }
#  local_flux_odd_view_fluxnorm_var: { 'dim': [ 31, 1 ], 'dtype': float }
#  local_flux_even_view_fluxnorm_var: { 'dim': [ 31, 1 ], 'dtype': float }
#  tce_bin_oedp_stat_norm: {'dim': [1,], 'dtype': float}
###    odd_std_oot_bin_norm: {'dim': [1,], 'dtype': float}
###    even_std_oot_bin_norm: {'dim': [1,], 'dtype': float}
###  odd_se_oot_norm: { 'dim': [ 1, ], 'dtype': float }
###  even_se_oot_norm: { 'dim': [ 1, ], 'dtype': float }

#  # centroid related features
###  global_centr_view_std_noclip: { 'dim': [ 301, 1 ], 'dtype': float }
#  local_centr_view_std_noclip: { 'dim': [ 31, 1 ], 'dtype': float }
#  local_centr_view_std_noclip_var: { 'dim': [ 31, 1 ], 'dtype': float }
#  tce_fwm_stat_norm: { 'dim': [ 1, ], 'dtype': float }
#  tce_dicco_msky_norm: { 'dim': [ 1, ], 'dtype': float }
#  tce_dicco_msky_err_norm: { 'dim': [ 1, ], 'dtype': float }
#  tce_dikco_msky_norm: { 'dim': [ 1, ], 'dtype': float }
#  tce_dikco_msky_err_norm: { 'dim': [ 1, ], 'dtype': float }
#  #  mag_norm: { 'dim': [ 1, ], 'dtype': float }
##  mag_cat: { 'dim': [ 1, ], 'dtype': int }
#  mag_cat_norm: { 'dim': [ 1, ], 'dtype': float }
#  ruwe_norm: { 'dim': [ 1, ], 'dtype': float }
#  mag_shift_norm: { 'dim': [ 1, ], 'dtype': float }

#  # secondary related features
##  # local_weak_secondary_view_fluxnorm: {'dim': [31, 1], 'dtype': float}
#  local_weak_secondary_view_selfnorm: { 'dim': [ 31, 1 ], 'dtype': float }
#  local_weak_secondary_view_selfnorm_var: { 'dim': [ 31, 1 ], 'dtype': float }
###  local_weak_secondary_view_max_flux-wks_norm: { 'dim': [ 31, 1 ], 'dtype': float }
#  tce_maxmes_norm: { 'dim': [ 1, ], 'dtype': float }
##  wst_depth_norm: { 'dim': [ 1, ], 'dtype': float }
  tce_albedo_stat_norm: { 'dim': [ 1, ], 'dtype': float }
#  tce_ptemp_stat_norm: { 'dim': [ 1, ], 'dtype': float }

  # other diagnostic parameters

 # bootstrap fa prob
#  boot_fap_norm: { 'dim': [ 1, ], 'dtype': float }

 # ghost
#  tce_cap_stat_norm: { 'dim': [ 1, ], 'dtype': float }
#  tce_hap_stat_norm: { 'dim': [ 1, ], 'dtype': float }
 #    tce_cap_hap_stat_diff_norm: {'dim': [1,], 'dtype': float}

  # rolling band
#  tce_rb_tcount0n_norm: { 'dim': [ 1, ], 'dtype': float }
#  #    tce_rb_tcount0_norm: { 'dim': [1,], 'dtype': float}

 # stellar parameters
#  tce_sdens_norm: { 'dim': [ 1, ], 'dtype': float }
#  tce_steff_norm: { 'dim': [ 1, ], 'dtype': float }
#  tce_smet_norm: { 'dim': [ 1, ], 'dtype': float }
#  tce_slogg_norm: { 'dim': [ 1, ], 'dtype': float }
#  tce_smass_norm: { 'dim': [ 1, ], 'dtype': float }
#  tce_sradius_norm: { 'dim': [ 1, ], 'dtype': float }

 # tce parameters
#  tce_prad_norm: { 'dim': [ 1, ], 'dtype': float }
#  tce_period_norm: { 'dim': [ 1, ], 'dtype': float }

  # difference image
#  diff_imgs_std_trainset: { 'dim': [ 33, 33, 5 ], 'dtype': float }
#  oot_imgs_std_trainset: { 'dim': [ 33, 33, 5 ], 'dtype': float }
#   diff_imgs_stdnorm: { 'dim': [ 33, 33, 5 ], 'dtype': float }
#   oot_imgs_stdnorm: { 'dim': [ 33, 33, 5 ], 'dtype': float }
#   target_imgs: { 'dim': [ 33, 33, 5 ], 'dtype': float }
#   quality: { 'dim': [ 5, 1], 'dtype': float }

  # momentum dump
#  local_momentum_dump_view: { 'dim': [ 31, 1 ], 'dtype': float }
#  local_momentum_dump_view_var: { 'dim': [ 31, 1 ], 'dtype': float }

#  # mission flag
#  mission: { 'dim': [ 1, ], 'dtype': float }

# maps features' names to features names expected by the model
feature_map: null
#  feature_name: feature_name_model

label_field_name: label  # name of the label field in the TFRecord that is going to be used as the label

inference:
  batch_size: 32

callbacks:
#  early_stopping:
#    monitor: val_auc_pr  # val_auc_pr  # which metric used to monitor for early stopping
#    min_delta: 0
#    patience: 20
#    verbose: 1
#    mode: max  # maximize/minimize monitored metric in early stopping
#    baseline: null
#    restore_best_weights: true  # get model from epoch that had the best performance according to monitored metric
  tensorboard:
    histogram_freq: 1
    write_graph: true
    write_images: false
    update_freq: epoch
    profile_batch: 2
    embeddings_metadata: null
    embeddings_freq: 0

label_map:  # maps label to a label id
#  # Kepler
#  PC: 1
#  AFP: 0
#  NTP: 0
  # TESS
  KP: 1
  CP: 1
  FP: 0
#  FA: 0
  EB: 0
#  B: 0
#  J: 0
  NTP: 0
  # Kepler Sim
#  INJ1: 1
#  INJ2: 0
#  INJ3: 0
#  SCR1: 0
#  SCR2: 0
#  INV: 0

datasets:
  - predict
#  - train
#  - val
#  - test

plot_model: true
write_model_summary: true
verbose_model: 2  # for fit, eval, predict functions
verbose: true  # general
